# **CLI 交互式冲突解决算法总纲**

**核心目标**：构建一个命令行工具，该工具接收用户指定的待编译模块列表（可包含模块组），自动检测并以交互方式解决模块间的编译冲突，最终生成一个无冲突的、完整的编译任务列表。

## 一、 核心数据模型

程序必须预先加载一个**冲突图 (Conflict Graph)**。此图定义了所有模块间的互斥关系。推荐使用邻接表实现，例如 `Map<String, Set<String>>`。

## 二、 算法执行流程

1. **输入解析与扩展 (Expansion)**
    a. 接收用户从命令行输入的所有参数（模块名和组名）。
    b. 解析配置文件，将所有组名参数替换为其包含的模块列表。
    c. 将所有模块合并并去重，形成“初始意图集”。
    d. 递归解析“初始意图集”中所有模块的依赖关系，将所有依赖项加入集合，形成最终的“待编译全集”。

2. **冲突检测 (Detection)**
    a. 基于“待编译全集”和预加载的“冲突图”，构建一个仅包含待编译模块的冲突子图。
    b. 在此子图上运行**最大团查找算法** (例如 Bron-Kerbosch)，找出所有独立的、互斥的模块组（即“冲突组”列表）。

3. **交互式解决 (Resolution)**
    a. 初始化一个空的“最终编译列表”。
    b. 将“待编译全集”中所有**未出现在任何冲突组里**的模块，直接添加到“最终编译列表”中。
    c. **遍历“冲突组”列表，对每一个冲突组执行以下操作**：
        i. **检查是否已解决**：检查当前冲突组内的模块是否已因之前的决策而被排除。如果组内只剩下一个或零个可选模块，则自动处理并跳过用户交互。
        ii. **用户交互**：如果冲突仍需解决，向用户显示一个带编号的菜单，列出当前冲突组中的所有模块，并额外提供一个 `[0]` 选项表示“全部不选”。
        iii. **记录决策**：根据用户的数字输入，将用户选择的模块（如果有）加入“最终编译列表”，并记录下所有被用户放弃的模块。

4. **最终确认与执行 (Confirmation & Execution)**
    a. 所有冲突组处理完毕后，“最终编译列表”即为无冲突的最终方案。
    b. 向用户清晰地展示“最终编译列表”的内容。
    c. 请求用户做最后的确认（例如 `[Y/n]`）。
    d. 若用户确认，则将列表传递给后端编译脚本执行。

## 三、 核心场景处理方式

本算法能够统一处理所有可能的情况：

* **情况A：无冲突**
  * 在步骤 `2.b` 中，“冲突组”列表为空。
  * 步骤 `3` 的交互流程被完全跳过。
  * 程序直接展示完整的“待编译全集”并请求确认。

* **情况B：简单的一对一冲突** (例如 `ego_planner` 与 `fuel_planner`)
  * 步骤 `2.b` 找到一个只包含两个模块的冲突组 `[{ego_planner, fuel_planner}]`。
  * 步骤 `3.c` 的循环只执行一次，向用户展示一个 `[1] ego_planner`, `[2] fuel_planner`, `[0] 全不选` 的菜单。
  * 用户的决策直接决定了最终编译列表。

* **情况C：复杂的多组交叉冲突** (例如 `A, B, C, D` 的例子)
  * 步骤 `2.b` 找到多个冲突组，例如 `[{A, B, C}]` 和 `[{B, D}]`。
  * 步骤 `3.c` 的循环会执行多次：
        1. **处理第一个组 `{A, B, C}`**：程序向用户展示 A, B, C 的三选一菜单。假设用户选择了 `B`。此时，`B` 被加入“最终编译列表”，而 `A` 和 `C` 被记录为“已放弃”。
        2. **处理第二个组 `{B, D}`**：在向用户提问前，程序执行步骤 `3.c.i`，它检查发现：
            *`B` 已经被用户选择。
            * 根据“B与D互斥”的规则，`D` 必须被放弃。
            * 此冲突已由用户的上一个选择**自动解决**。
        3. 程序将**跳过**向用户提问，并可选择性地告知用户 `“根据您选择'B'的决定，'D'已被自动排除”`。
  * 最终，所有冲突都得到解决，流程继续。

这个算法通过**状态化**的解决流程（每一步决策都会影响后续步骤的判断），确保了无论是简单还是复杂的冲突，都能以最少、最清晰的交互次数来高效解决。
